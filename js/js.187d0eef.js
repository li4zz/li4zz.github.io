(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["js"],{"6c10":function(p,n,t){"use strict";t.r(n);var i=function(){var p=this;p._self._c;return p._m(0)},o=[function(){var p=this,n=p._self._c;return n("div",[n("h3",[p._v("一、闭包")]),n("p",[p._v(" 当一个函数中的内部函数被拿到函数外部调用，又因为在js中内层作用域总是能访问外层作用域的变量，那么内部函数存在对外部函数中变量的引用，这些变量的集合称之为闭包。 ")]),n("p",[p._v("function foo() {")]),n("p",[p._v("let a = 1")]),n("p",[p._v("let b = 2")]),n("p",[p._v("function bar() {")]),n("p",[p._v("    console.log(a); // 这里的a就是闭包")]),n("p",[p._v("}")]),n("p",[p._v("return bar")]),n("p",[p._v("}")]),n("p",[p._v("let baz = foo()")]),n("p",[p._v("baz() // 1")]),n("p",[p._v(" 应用场景：1，创建私有变量 （全局变量不易维护）,2，延长变量的生命周期 ,3，实现柯里化（颗粒） ")]),n("p",[p._v("缺点：内存泄露：函数的执行上下文销毁的不彻底，内存空间变小")]),n("h3",[p._v("二、什么是柯里化（颗粒化）")]),n("p",[p._v("将一个接受多个参数的函数转变成多个只接受一个参数的函数")]),n("p",[p._v("function add(a, b, c) {")]),n("p",[p._v("    return a + b + c")]),n("p",[p._v("}")]),n("p",[p._v("function add(a) {")]),n("p",[p._v("    return function(b) {")]),n("p",[p._v("        return function(c) {")]),n("p",[p._v("             return a + b + c ")]),n("p",[p._v("        }")]),n("p",[p._v("   }")]),n("p",[p._v("}")]),n("p",[p._v("const res = add(1)(2)(3)")]),n("p",[p._v("console.log(res); // 6")]),n("h3",[p._v("三、作用域")]),n("p",[p._v("作用域是什么：变量和函数能够生效的区域，这个区域叫作用域")]),n("p",[p._v(" 全局作用域： 在V8执行代码的过程中会进行预编译，预编译会生成一个全局执行上下文， 这个全局执行上下文就是全局作用域，里面定义了声明在最外层的变量和函数 ")]),n("p",[p._v(" 函数体作用域： 在代码的执行过程中，遇到函数的调用时会生成一个函数的执行上下文，这个函数执行上下文就是函数体的作用域，里面定义了声明在函数内部的变量和函数 ")]),n("p",[p._v("块级作用域： let或const和{}形成的区域就叫做块级作用域")]),n("p",[p._v(" 作用域链：作用域只能从内到外的访问，这种访问规则形成的链状关系我们称之为作用域链 ")]),n("p",[p._v("词法作用域：指的是函数或变量定义的区域")]),n("h3",[p._v(" 四、call 、 apply 、 bind 作⽤是改变函数执⾏时的上下⽂，简⽽⾔之就是改变函数运⾏时 的 this 指向 那么什么情况下需要改变 this 的指向呢？ ")]),n("p",[p._v('var name = "lucy";')]),n("p",[p._v(' var obj = { name: "martin", say: function () { console.log(this.name)} }; ')]),n("p",[p._v("obj.say(); // martin，this 指向 obj 对象")]),n("p",[p._v("setTimeout(obj.say,0); // lucy，this 指向 window 对象")]),n("p",[p._v(" 从上⾯可以看到，正常情况 say ⽅法输出 martin 但是我们把 say 放在 setTimeout ⽅法中，在定时器中是作为回调函数来执⾏的，因此回到主栈执 ⾏时是在全局执⾏上下⽂的环境中执⾏的，这时候 this 指向 window ，所以输出 lucy 我们实际需要的是 this 指向 obj 对象，这时候就需要该改变 this 指向了 ")]),n("p",[p._v("setTimeout(obj.say.bind(obj),0); //martin，this指向obj对象")]),n("div",{staticStyle:{"margin-top":"30px"}}),n("p",{staticStyle:{"font-weight":"bold"}},[p._v("apply")]),n("p",[p._v(" apply 接受两个参数，第⼀个参数是 this 的指向，第⼆个参数是函数接受的参数，以数组的形式传 ⼊ 改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次 ")]),n("p",[p._v("function fn(...args){ console.log(this,args); }")]),n("p",[p._v('let obj = { myname:"张三" }')]),n("p",[p._v(" fn.apply(obj,[1,2]); // this会变成传⼊的obj，传⼊的参数必须是⼀个数组； ")]),n("p",[p._v("fn(1,2) // this指向window")]),n("p",[p._v("当第⼀个参数为 null 、 undefined 的时候，默认指向 window (在浏览器中)")]),n("p",[p._v("fn.apply(null,[1,2]); // this指向window")]),n("p",[p._v("fn.apply(undefined,[1,2]); // this指向window")]),n("p",{staticStyle:{"font-weight":"bold"}},[p._v("call")]),n("p",[p._v(" call ⽅法的第⼀个参数也是 this 的指向，后⾯传⼊的是⼀个参数列表 跟 apply ⼀样，改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次 ")]),n("p",[p._v("function fn(...args){ console.log(this,args); }")]),n("p",[p._v('let obj = { myname:"张三" }')]),n("p",[p._v("fn.call(obj,1,2); // this会变成传⼊的obj，传⼊的参数必须是⼀个数组；")]),n("p",[p._v("fn(1,2) // this指向window")]),n("p",[p._v(" 同样的，当第⼀个参数为 null 、 undefined 的时候，默认指向 window (在浏览器中) ")]),n("p",[p._v("fn.call(null,[1,2]); // this指向window")]),n("p",[p._v("fn.call(undefined,[1,2]); // this指向window")]),n("p",{staticStyle:{"font-weight":"bold"}},[p._v("bind")]),n("p",[p._v(" bind⽅法和call很相似，第⼀参数也是 this 的指向，后⾯传⼊的也是⼀个参数列表(但是这个参数列表 可以分多次传⼊) 改变 this 指向后不会⽴即执⾏， ")]),n("p",[p._v('let obj = { myname:"张三" }')]),n("p",[p._v(" const bindFn = fn.bind(obj); // this 也会变成传⼊的obj ，bind不是⽴即执⾏需要执 ⾏⼀次 ")]),n("p",[p._v(" function fn(...args){ console.log(this,args); } bindFn(1,2) // this指向obj ")]),n("p",[p._v("fn(1,2) // this指向window")]),n("p",{staticStyle:{"font-weight":"bold"}},[p._v("⼩结")]),n("p",[p._v("从上⾯可以看到， apply 、 call 、 bind 三者的区别在于：")]),n("p",[p._v("三者都可以改变函数的 this 对象指向")]),n("p",[p._v(" 三者第⼀个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 nul l ，则默认指向全局 window ")]),n("p",[p._v(" 三者都可以传参，但是 apply 是数组，⽽ call 是参数列表，且 apply 和 call 是⼀次性传 ⼊参数，⽽ bind 可以分为多次传⼊ ")]),n("p",[p._v("bind 是返回绑定this之后的函数， apply 、 call 则是⽴即执⾏")]),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p"),n("p")])}],l={data(){return{}}},v=l,s=t("2877"),_=Object(s["a"])(v,i,o,!1,null,"3581e687",null);n["default"]=_.exports}}]);
//# sourceMappingURL=js.187d0eef.js.map