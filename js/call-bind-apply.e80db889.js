(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["call-bind-apply"],{"64f0":function(n,i,t){"use strict";t.r(i);var l=function(){var n=this;n._self._c;return n._m(0)},p=[function(){var n=this,i=n._self._c;return i("div",[n._v(" call 、 apply 、 bind 作⽤是改变函数执⾏时的上下⽂，简⽽⾔之就是改变函数运⾏时 的 this 指向 那么什么情况下需要改变 this 的指向呢？下⾯举个例⼦ "),i("p",[n._v('var name = "lucy";')]),i("p",[n._v(' var obj = { name: "martin", say: function () { console.log(this.name)} }; ')]),i("p",[n._v("obj.say(); // martin，this 指向 obj 对象")]),i("p",[n._v("setTimeout(obj.say,0); // lucy，this 指向 window 对象")]),i("p",[n._v(" 从上⾯可以看到，正常情况 say ⽅法输出 martin 但是我们把 say 放在 setTimeout ⽅法中，在定时器中是作为回调函数来执⾏的，因此回到主栈执 ⾏时是在全局执⾏上下⽂的环境中执⾏的，这时候 this 指向 window ，所以输出 lucy 我们实际需要的是 this 指向 obj 对象，这时候就需要该改变 this 指向了 ")]),i("p",[n._v("setTimeout(obj.say.bind(obj),0); //martin，this指向obj对象")]),i("div",{staticStyle:{"margin-top":"30px"}}),i("p",{staticStyle:{"font-weight":"bold"}},[n._v("apply")]),i("p",[n._v(" apply 接受两个参数，第⼀个参数是 this 的指向，第⼆个参数是函数接受的参数，以数组的形式传 ⼊ 改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次 ")]),i("p",[n._v("function fn(...args){ console.log(this,args); }")]),i("p",[n._v('let obj = { myname:"张三" }')]),i("p",[n._v(" fn.apply(obj,[1,2]); // this会变成传⼊的obj，传⼊的参数必须是⼀个数组； ")]),i("p",[n._v("fn(1,2) // this指向window")]),i("p",[n._v("当第⼀个参数为 null 、 undefined 的时候，默认指向 window (在浏览器中)")]),i("p",[n._v("fn.apply(null,[1,2]); // this指向window")]),i("p",[n._v("fn.apply(undefined,[1,2]); // this指向window")]),i("p",{staticStyle:{"font-weight":"bold"}},[n._v("call")]),i("p",[n._v(" call ⽅法的第⼀个参数也是 this 的指向，后⾯传⼊的是⼀个参数列表 跟 apply ⼀样，改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次 ")]),i("p",[n._v("function fn(...args){ console.log(this,args); }")]),i("p",[n._v('let obj = { myname:"张三" }')]),i("p",[n._v("fn.call(obj,1,2); // this会变成传⼊的obj，传⼊的参数必须是⼀个数组；")]),i("p",[n._v("fn(1,2) // this指向window")]),i("p",[n._v(" 同样的，当第⼀个参数为 null 、 undefined 的时候，默认指向 window (在浏览器中) ")]),i("p",[n._v("fn.call(null,[1,2]); // this指向window")]),i("p",[n._v("fn.call(undefined,[1,2]); // this指向window")]),i("p",{staticStyle:{"font-weight":"bold"}},[n._v("bind")]),i("p",[n._v(" bind⽅法和call很相似，第⼀参数也是 this 的指向，后⾯传⼊的也是⼀个参数列表(但是这个参数列表 可以分多次传⼊) 改变 this 指向后不会⽴即执⾏， ")]),i("p",[n._v('let obj = { myname:"张三" }')]),i("p",[n._v(" const bindFn = fn.bind(obj); // this 也会变成传⼊的obj ，bind不是⽴即执⾏需要执 ⾏⼀次 ")]),i("p",[n._v(" function fn(...args){ console.log(this,args); } bindFn(1,2) // this指向obj ")]),i("p",[n._v("fn(1,2) // this指向window")]),i("p",{staticStyle:{"font-weight":"bold"}},[n._v("⼩结")]),i("p",[n._v("从上⾯可以看到， apply 、 call 、 bind 三者的区别在于：")]),i("p",[n._v("三者都可以改变函数的 this 对象指向")]),i("p",[n._v(" 三者第⼀个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 nul l ，则默认指向全局 window ")]),i("p",[n._v(" 三者都可以传参，但是 apply 是数组，⽽ call 是参数列表，且 apply 和 call 是⼀次性传 ⼊参数，⽽ bind 可以分为多次传⼊ ")]),i("p",[n._v("bind 是返回绑定this之后的函数， apply 、 call 则是⽴即执⾏")]),i("p")])}],s={data(){return{}}},o=s,a=t("2877"),e=Object(a["a"])(o,l,p,!1,null,"8bebf24a",null);i["default"]=e.exports}}]);
//# sourceMappingURL=call-bind-apply.e80db889.js.map