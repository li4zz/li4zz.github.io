{"version":3,"sources":["webpack:///./src/views/vue.vue","webpack:///src/views/vue.vue","webpack:///./src/views/vue.vue?117e","webpack:///./src/views/vue.vue?7569","webpack:///./src/assets/images/2.gif"],"names":["render","_vm","this","_self","_c","_m","staticRenderFns","_v","attrs","require","data","component","module","exports"],"mappings":"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","file":"js/vue.1fc96c0c.js","sourcesContent":["var render = function render(){var _vm=this,_c=_vm._self._c;return _vm._m(0)\n}\nvar staticRenderFns = [function (){var _vm=this,_c=_vm._self._c;return _c('div',[_c('h3',[_vm._v(\"一、Vue 3 的常用 API\")]),_c('p',[_vm._v(\" ref：用于创建基本数据类型（如字符串、数字、布尔值等）的响应式引用。ref 通过 .value 来访问和修改数据。 \")]),_c('p',[_vm._v(\" reactive：用于创建对象或数组的响应式数据，直接对对象进行响应式代理。修改对象的属性时，可以直接通过属性名来访问和修改。 \")]),_c('p',[_vm._v(\" computed 用于创建计算属性，计算属性会基于它所依赖的响应式数据进行缓存。只有依赖的响应式数据发生变化时，才会重新计算。适用于衍生数据或需要基于其他数据计算的场景。 \")]),_c('p',[_vm._v(\" watch 用于监听某个响应式数据的变化，并执行副作用操作。适合用于异步操作或其他副作用（如数据存储、API 请求等）。 \")]),_c('p',[_vm._v(\" 生命周期函数（组合式 API） onMounted、onUpdated、onUnmounted：这些生命周期函数在组件的不同生命周期阶段执行，类似于 Vue 2 的生命周期钩子。 它们与 Vue 2 的选项式 API 生命周期钩子不同，采用了组合式 API，更加灵活和清晰。 \")]),_c('p',[_vm._v(\" defineComponent 用于定义组件，是 Vue 3 的标准组件定义方式。它支持组合式 API 和 TypeScript 类型推导，增强了组件的可读性和类型安全。 \")]),_c('p',[_vm._v(\" provide 和 inject provide 和 inject 是 Vue 3 中用于跨层级组件通信的 API。父组件通过 provide 提供数据，子组件通过 inject 获取数据，适用于多层级嵌套的组件树中。 \")]),_c('p',[_vm._v(\" nextTick 用于在 DOM 更新后执行某些操作。通常在修改数据后，Vue 会异步更新 DOM，而 nextTick 可以保证 DOM 更新完成后执行回调函数。 \")]),_c('p',[_vm._v(\" useContext 用于获取当前组件的上下文，适用于函数式组件中访问 Vue 的上下文信息。 \")]),_c('h3',[_vm._v(\"二、ref 和 reactive 的区别\")]),_c('p',[_vm._v(\" ref 用于创建基本数据类型的响应式引用，它会包装原始数据，如字符串、数字等，访问时需要通过 .value。 \")]),_c('p',[_vm._v(\" reactive 用于创建对象或数组的响应式数据，直接对对象进行响应式代理，可以直接通过属性名来访问。 \")]),_c('p',[_vm._v(\" 这两者可以结合使用，例如： const count = ref(0); const user = reactive({ name: 'Alice', age: 25 }); \")]),_c('h3',[_vm._v(\"三、computed 和 watch 的区别\")]),_c('p',[_vm._v(\" computed：适用于需要衍生数据或缓存计算结果的场景。它只会在依赖的数据变化时重新计算，避免不必要的性能开销。 适用场景：表单的校验规则、动态标题、数据转换等。 \")]),_c('p',[_vm._v(\" watch：用于侦听响应式数据的变化，并执行副作用操作。适用于异步操作或复杂的副作用，如数据提交、API 请求等。 \")]),_c('p',[_vm._v(\"适用场景：请求外部 API、表单提交、页面跳转等。\")]),_c('h3',[_vm._v(\"四、Vue 2 的 mixin 和 Vue 3 的 hooks 的相似之处和区别\")]),_c('p',[_vm._v(\" 相似之处： mixin 和 hooks 都可以用于逻辑复用，将多个组件中共享的功能提取到外部，使得代码更加模块化和可维护。 \")]),_c('p',[_vm._v(\" 区别：Mixin：Vue 2 的 mixin 是将多个组件选项中的逻辑混入当前组件，可能导致命名冲突或代码可维护性差，尤其在大型应用中。 Hooks（Vue 3） ：Vue 3 提供的组合式 API 允许更加灵活和模块化的代码组织，避免了 mixin 中的命名冲突，逻辑更加清晰和可组合。 \")]),_c('h3',[_vm._v(\"五、Vue 3 组件生命周期及替代 API\")]),_c('p',[_vm._v(\" 在 Vue 3 中，组件生命周期方法与 Vue 2 略有不同。Vue 2 中的生命周期方法包括：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed。这些方法描述了组件从创建到销毁的各个阶段。 \")]),_c('p',[_vm._v(\"beforeCreate: 在实例创建之前被调用。\")]),_c('p',[_vm._v(\"created: 实例创建后调用，数据观测和事件配置已完成，但 DOM 尚未挂载。\")]),_c('p',[_vm._v(\"beforeMount: 在挂载开始之前调用，此时 DOM 尚未被渲染。\")]),_c('p',[_vm._v(\"mounted: 组件挂载完成后调用，DOM 已渲染并可访问。\")]),_c('p',[_vm._v(\"beforeUpdate: 在组件数据变化时调用，DOM 尚未更新。\")]),_c('p',[_vm._v(\"updated: 在组件数据变化后，DOM 更新完毕后调用。\")]),_c('p',[_vm._v(\"beforeDestroy: 在组件销毁前调用。\")]),_c('p',[_vm._v(\"destroyed: 在组件销毁后调用。\")]),_c('p',[_vm._v(\" 在 Vue 3 中，组合式 API 替代了传统的生命周期方法。常用的替代方法包括： onMounted: 替代 mounted，用于在组件挂载完成后执行操作。 onUpdated: 替代 updated，用于在组件更新后执行操作。 通过组合式 API，生命周期方法可以在多个 setup() 中进行逻辑复用，增强了代码的可维护性和复用性。 \")]),_c('h3',[_vm._v(\"六、Vue 2 与 Vue 3 的区别\")]),_c('p',[_vm._v(\" 性能：Vue 3 引入了更高效的虚拟 DOM 和响应式系统，整体性能得到了大幅提升。特别是在大型应用中，Vue 3 的响应式性能比 Vue 2 更优。 \")]),_c('p',[_vm._v(\" 组合式 API：Vue 3 增加了组合式 API（Composition API），让开发者能通过 setup() 函数集中定义响应式状态、计算属性和生命周期钩子，提升了逻辑复用性和代码的可读性。 \")]),_c('p',[_vm._v(\" TypeScript 支持：Vue 3 对 TypeScript 的支持更加完善，提供了更好的类型推导和静态类型检查，增强了开发体验。 \")]),_c('p',[_vm._v(\" 响应式系统：Vue 3 使用了基于 Proxy 的响应式系统，相比于 Vue 2 中使用的 Object.defineProperty，Proxy 提供了更高的性能和更强的灵活性，能够更好地处理嵌套对象和数组。 \")]),_c('h3',[_vm._v(\"七、Vue 2 响应式与 Vue 3 响应式的区别\")]),_c('p',[_vm._v(\" Vue 2: 使用 Object.defineProperty 通过劫持对象的 getter 和 setter 来实现响应式。这种方式的缺点包括无法检测到数组索引的变化，且对于嵌套对象的处理也相对有限。 \")]),_c('p',[_vm._v(\" Vue 3: 使用 Proxy 实现响应式，提供了更强大的功能。Proxy 可以直接代理整个对象，支持嵌套对象、数组及其变化的检测，并且性能也比 Object.defineProperty 更好。 \")]),_c('h3',[_vm._v(\"八、Vue 组件通信\")]),_c('p',[_vm._v(\" 父子组件通信： 父组件通过 props 向子组件传递数据。 子组件通过 $emit 向父组件发送事件，实现双向数据流。 \")]),_c('p',[_vm._v(\" 兄弟组件通信： 通过公共父组件传递数据，父组件将数据传递给两个兄弟组件。 或者通过 provide 和 inject 实现祖先和后代组件之间的通信。 \")]),_c('p',[_vm._v(\" 跨层级通信： 可以使用状态管理库，如 Vuex 或 Pinia，来管理全局状态，确保跨层级的组件都能访问和修改共享的数据。 事件总线也是一种常见的跨层级通信方式，虽然在 Vue 3 中已经不推荐使用。 \")]),_c('h3',[_vm._v(\"九、Vuex 与 Pinia 的区别\")]),_c('p',[_vm._v(\" Vuex：Vuex 是 Vue 2.x 的官方状态管理库。它使用 mutations 和 actions 来处理状态变更，管理全局状态，并且需要通过显式的 commit 和 dispatch 操作。 \")]),_c('p',[_vm._v(\" Pinia：Pinia 是 Vue 3 推荐的状态管理库。它基于组合式 API，支持更好的类型推导、响应式状态管理，并且 API 更加简洁。Pinia 在 Vue 3 中的表现更自然，并且对于 TypeScript 的支持也更加友好。 \")]),_c('p',[_vm._v(\" 总结： Vuex 适用于 Vue 2 项目，而 Pinia 更适合 Vue 3 项目。 Pinia 提供了更简洁和现代化的 API，更好地集成了 Vue 3 的组合式 API。 \")]),_c('h3',[_vm._v(\"十、选项式 API 和 组合式 API 的区别\")]),_c('p',[_vm._v(\" 选项式 API： 通过组件的选项（如 data, methods, computed, watch 等）来组织逻辑。 结构化明确，但对于大型或复杂的应用来说，代码容易变得繁琐且不易维护。 适用于小型到中型的项目，易于上手。 \")]),_c('p',[_vm._v(\" 组合式 API： 通过函数来组织组件的逻辑，使用 setup() 函数进行组合。 逻辑复用性更强，可以按功能拆分逻辑，提高可维护性和可扩展性。 特别适用于复杂的组件，能够提高代码的模块化程度，增强可读性和测试性。 \")]),_c('p',[_vm._v(\" 总结：选项式 API 适合小型或中型项目，而组合式 API 更适合复杂或大型项目，且具有更高的灵活性和可复用性。 \")]),_c('h3',[_vm._v(\"十一、Vue 中的虚拟 DOM，diff 算法\")]),_c('p',[_vm._v(\" 虚拟 DOM： Vue 使用虚拟 DOM 来优化页面渲染过程。当组件的数据发生变化时，Vue 会首先创建一个虚拟 DOM 树，而不是直接修改真实的 DOM。 \")]),_c('p',[_vm._v(\" Diff 算法： 当数据发生变化时，Vue 会用新生成的虚拟 DOM 树与旧的虚拟 DOM 树进行比较（diff）。它通过最小化的更新策略，计算出最小的 DOM 变更，最终应用到真实的 DOM 上。 这一过程显著提升了渲染性能，尤其是在数据频繁变动的场景中。 \")]),_c('p',[_vm._v(\" 总结：虚拟 DOM 和 Diff 算法的结合使得 Vue 在进行 DOM 更新时更加高效，减少了不必要的 DOM 操作，提高了性能。 \")]),_c('h3',[_vm._v(\"十二、Vue 3 里面的劫持有哪些\")]),_c('p',[_vm._v(\" Vue 3 使用 Proxy 来实现响应式系统，取代了 Vue 2 中的 Object.defineProperty。 Proxy 可以拦截对象的读取、设置、删除等操作，并通过代理机制来触发视图的更新。 通过对对象进行代理，Vue 3 可以更高效地追踪数据变化，并实现响应式更新。 \")]),_c('p',[_vm._v(\" 总结：Vue 3 通过 Proxy 实现对数据的劫持和响应式更新，较 Vue 2 提升了性能并简化了代码逻辑。 \")]),_c('h3',[_vm._v(\"十三、Vue SSR 的实现原理\")]),_c('p',[_vm._v(\" Vue SSR（服务器端渲染）通过在服务器端渲染页面，再将渲染后的 HTML 发送给客户端，可以显著提升 SEO 和首屏加载性能。在 Vue 3 中，SSR 通过 \")]),_c('p',[_vm._v(\" renderToString 和 createApp 实现。 createApp：用于创建 Vue 应用的实例。 \")]),_c('p',[_vm._v(\"renderToString：将 Vue 应用渲染为 HTML 字符串并返回给客户端。\")]),_c('p',[_vm._v(\" 这种机制让客户端能够尽早展示页面内容，而不是等待 JavaScript 加载和执行后再渲染，从而提升了性能和 SEO。 \")]),_c('h3',[_vm._v(\"十四、props和data的优先级谁高\")]),_c('p',[_vm._v(\"props > methosd > data > computed > watch\")]),_c('h3',[_vm._v(\"十五、路由独享\")]),_c('p',[_vm._v(\"{\")]),_c('p',[_vm._v(\"    path: '/mainpage',\")]),_c('p',[_vm._v(\"    name: 'About',\")]),_c('p',[_vm._v(\"    component: About, // 路由独享守卫\")]),_c('p',[_vm._v(\"    beforeEnter:(to,from,next) => {\")]),_c('p',[_vm._v(\"         if  (from.name === '/mainpage/about'){ \")]),_c('p',[_vm._v(\"             alert(\\\"这是从about来的\\\") \")]),_c('p',[_vm._v(\"        }  else{\")]),_c('p',[_vm._v(\"             alert(\\\"这不是从about来的\\\") \")]),_c('p',[_vm._v(\"         } next(); // 必须调用来进行下一步操作。否则是不会跳转的 \")]),_c('p',[_vm._v(\"    }\")]),_c('p',[_vm._v(\"}\")]),_c('h3',[_vm._v(\"十六、常见的事件修饰符及其作用\")]),_c('p',[_vm._v(\" .stop： 防止事件冒泡（等同于 JavaScript 中的 event.stopPropagation()） \")]),_c('p',[_vm._v(\" .prevent： 防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）等同于 JavaScript 中的 event.preventDefault() \")]),_c('p',[_vm._v(\".capture ：与事件冒泡的方向相反，事件捕获由外到内；\")]),_c('p',[_vm._v(\".self ：只会触发自己范围内的事件，不包含子元素；\")]),_c('p',[_vm._v(\".once ：只会触发一次。\")]),_c('img',{attrs:{\"src\":require(\"@/assets/images/2.gif\")}}),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p')])\n}]\n\nexport { render, staticRenderFns }","<!-- vue篇 -->\r\n<template>\r\n  <div>\r\n    <h3>一、Vue 3 的常用 API</h3>\r\n    <p>\r\n      ref：用于创建基本数据类型（如字符串、数字、布尔值等）的响应式引用。ref\r\n      通过 .value 来访问和修改数据。\r\n    </p>\r\n    <p>\r\n      reactive：用于创建对象或数组的响应式数据，直接对对象进行响应式代理。修改对象的属性时，可以直接通过属性名来访问和修改。\r\n    </p>\r\n    <p>\r\n      computed\r\n      用于创建计算属性，计算属性会基于它所依赖的响应式数据进行缓存。只有依赖的响应式数据发生变化时，才会重新计算。适用于衍生数据或需要基于其他数据计算的场景。\r\n    </p>\r\n    <p>\r\n      watch\r\n      用于监听某个响应式数据的变化，并执行副作用操作。适合用于异步操作或其他副作用（如数据存储、API\r\n      请求等）。\r\n    </p>\r\n    <p>\r\n      生命周期函数（组合式 API）\r\n      onMounted、onUpdated、onUnmounted：这些生命周期函数在组件的不同生命周期阶段执行，类似于\r\n      Vue 2 的生命周期钩子。 它们与 Vue 2 的选项式 API\r\n      生命周期钩子不同，采用了组合式 API，更加灵活和清晰。\r\n    </p>\r\n    <p>\r\n      defineComponent 用于定义组件，是 Vue 3 的标准组件定义方式。它支持组合式\r\n      API 和 TypeScript 类型推导，增强了组件的可读性和类型安全。\r\n    </p>\r\n    <p>\r\n      provide 和 inject provide 和 inject 是 Vue 3 中用于跨层级组件通信的\r\n      API。父组件通过 provide 提供数据，子组件通过 inject\r\n      获取数据，适用于多层级嵌套的组件树中。\r\n    </p>\r\n    <p>\r\n      nextTick 用于在 DOM 更新后执行某些操作。通常在修改数据后，Vue 会异步更新\r\n      DOM，而 nextTick 可以保证 DOM 更新完成后执行回调函数。\r\n    </p>\r\n    <p>\r\n      useContext 用于获取当前组件的上下文，适用于函数式组件中访问 Vue\r\n      的上下文信息。\r\n    </p>\r\n    <h3>二、ref 和 reactive 的区别</h3>\r\n    <p>\r\n      ref\r\n      用于创建基本数据类型的响应式引用，它会包装原始数据，如字符串、数字等，访问时需要通过\r\n      .value。\r\n    </p>\r\n    <p>\r\n      reactive\r\n      用于创建对象或数组的响应式数据，直接对对象进行响应式代理，可以直接通过属性名来访问。\r\n    </p>\r\n    <p>\r\n      这两者可以结合使用，例如： const count = ref(0); const user = reactive({\r\n      name: 'Alice', age: 25 });\r\n    </p>\r\n    <h3>三、computed 和 watch 的区别</h3>\r\n    <p>\r\n      computed：适用于需要衍生数据或缓存计算结果的场景。它只会在依赖的数据变化时重新计算，避免不必要的性能开销。\r\n      适用场景：表单的校验规则、动态标题、数据转换等。\r\n    </p>\r\n    <p>\r\n      watch：用于侦听响应式数据的变化，并执行副作用操作。适用于异步操作或复杂的副作用，如数据提交、API\r\n      请求等。\r\n    </p>\r\n    <p>适用场景：请求外部 API、表单提交、页面跳转等。</p>\r\n    <h3>四、Vue 2 的 mixin 和 Vue 3 的 hooks 的相似之处和区别</h3>\r\n    <p>\r\n      相似之处： mixin 和 hooks\r\n      都可以用于逻辑复用，将多个组件中共享的功能提取到外部，使得代码更加模块化和可维护。\r\n    </p>\r\n    <p>\r\n      区别：Mixin：Vue 2 的 mixin\r\n      是将多个组件选项中的逻辑混入当前组件，可能导致命名冲突或代码可维护性差，尤其在大型应用中。\r\n      Hooks（Vue 3） ：Vue 3 提供的组合式 API\r\n      允许更加灵活和模块化的代码组织，避免了 mixin\r\n      中的命名冲突，逻辑更加清晰和可组合。\r\n    </p>\r\n    <h3>五、Vue 3 组件生命周期及替代 API</h3>\r\n    <p>\r\n      在 Vue 3 中，组件生命周期方法与 Vue 2 略有不同。Vue 2\r\n      中的生命周期方法包括：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed。这些方法描述了组件从创建到销毁的各个阶段。\r\n    </p>\r\n    <p>beforeCreate: 在实例创建之前被调用。</p>\r\n    <p>created: 实例创建后调用，数据观测和事件配置已完成，但 DOM 尚未挂载。</p>\r\n    <p>beforeMount: 在挂载开始之前调用，此时 DOM 尚未被渲染。</p>\r\n    <p>mounted: 组件挂载完成后调用，DOM 已渲染并可访问。</p>\r\n    <p>beforeUpdate: 在组件数据变化时调用，DOM 尚未更新。</p>\r\n    <p>updated: 在组件数据变化后，DOM 更新完毕后调用。</p>\r\n    <p>beforeDestroy: 在组件销毁前调用。</p>\r\n    <p>destroyed: 在组件销毁后调用。</p>\r\n    <p>\r\n      在 Vue 3 中，组合式 API 替代了传统的生命周期方法。常用的替代方法包括：\r\n      onMounted: 替代 mounted，用于在组件挂载完成后执行操作。 onUpdated: 替代\r\n      updated，用于在组件更新后执行操作。 通过组合式 API，生命周期方法可以在多个\r\n      setup() 中进行逻辑复用，增强了代码的可维护性和复用性。\r\n    </p>\r\n    <h3>六、Vue 2 与 Vue 3 的区别</h3>\r\n    <p>\r\n      性能：Vue 3 引入了更高效的虚拟 DOM\r\n      和响应式系统，整体性能得到了大幅提升。特别是在大型应用中，Vue 3\r\n      的响应式性能比 Vue 2 更优。\r\n    </p>\r\n    <p>\r\n      组合式 API：Vue 3 增加了组合式 API（Composition API），让开发者能通过\r\n      setup()\r\n      函数集中定义响应式状态、计算属性和生命周期钩子，提升了逻辑复用性和代码的可读性。\r\n    </p>\r\n    <p>\r\n      TypeScript 支持：Vue 3 对 TypeScript\r\n      的支持更加完善，提供了更好的类型推导和静态类型检查，增强了开发体验。\r\n    </p>\r\n    <p>\r\n      响应式系统：Vue 3 使用了基于 Proxy 的响应式系统，相比于 Vue 2 中使用的\r\n      Object.defineProperty，Proxy\r\n      提供了更高的性能和更强的灵活性，能够更好地处理嵌套对象和数组。\r\n    </p>\r\n    <h3>七、Vue 2 响应式与 Vue 3 响应式的区别</h3>\r\n    <p>\r\n      Vue 2: 使用 Object.defineProperty 通过劫持对象的 getter 和 setter\r\n      来实现响应式。这种方式的缺点包括无法检测到数组索引的变化，且对于嵌套对象的处理也相对有限。\r\n    </p>\r\n    <p>\r\n      Vue 3: 使用 Proxy 实现响应式，提供了更强大的功能。Proxy\r\n      可以直接代理整个对象，支持嵌套对象、数组及其变化的检测，并且性能也比\r\n      Object.defineProperty 更好。\r\n    </p>\r\n    <h3>八、Vue 组件通信</h3>\r\n    <p>\r\n      父子组件通信： 父组件通过 props 向子组件传递数据。 子组件通过 $emit\r\n      向父组件发送事件，实现双向数据流。\r\n    </p>\r\n    <p>\r\n      兄弟组件通信： 通过公共父组件传递数据，父组件将数据传递给两个兄弟组件。\r\n      或者通过 provide 和 inject 实现祖先和后代组件之间的通信。\r\n    </p>\r\n    <p>\r\n      跨层级通信： 可以使用状态管理库，如 Vuex 或\r\n      Pinia，来管理全局状态，确保跨层级的组件都能访问和修改共享的数据。\r\n      事件总线也是一种常见的跨层级通信方式，虽然在 Vue 3 中已经不推荐使用。\r\n    </p>\r\n    <h3>九、Vuex 与 Pinia 的区别</h3>\r\n    <p>\r\n      Vuex：Vuex 是 Vue 2.x 的官方状态管理库。它使用 mutations 和 actions\r\n      来处理状态变更，管理全局状态，并且需要通过显式的 commit 和 dispatch 操作。\r\n    </p>\r\n    <p>\r\n      Pinia：Pinia 是 Vue 3 推荐的状态管理库。它基于组合式\r\n      API，支持更好的类型推导、响应式状态管理，并且 API 更加简洁。Pinia 在 Vue 3\r\n      中的表现更自然，并且对于 TypeScript 的支持也更加友好。\r\n    </p>\r\n    <p>\r\n      总结： Vuex 适用于 Vue 2 项目，而 Pinia 更适合 Vue 3 项目。 Pinia\r\n      提供了更简洁和现代化的 API，更好地集成了 Vue 3 的组合式 API。\r\n    </p>\r\n    <h3>十、选项式 API 和 组合式 API 的区别</h3>\r\n    <p>\r\n      选项式 API： 通过组件的选项（如 data, methods, computed, watch\r\n      等）来组织逻辑。\r\n      结构化明确，但对于大型或复杂的应用来说，代码容易变得繁琐且不易维护。\r\n      适用于小型到中型的项目，易于上手。\r\n    </p>\r\n    <p>\r\n      组合式 API： 通过函数来组织组件的逻辑，使用 setup() 函数进行组合。\r\n      逻辑复用性更强，可以按功能拆分逻辑，提高可维护性和可扩展性。\r\n      特别适用于复杂的组件，能够提高代码的模块化程度，增强可读性和测试性。\r\n    </p>\r\n    <p>\r\n      总结：选项式 API 适合小型或中型项目，而组合式 API\r\n      更适合复杂或大型项目，且具有更高的灵活性和可复用性。\r\n    </p>\r\n    <h3>十一、Vue 中的虚拟 DOM，diff 算法</h3>\r\n    <p>\r\n      虚拟 DOM： Vue 使用虚拟 DOM\r\n      来优化页面渲染过程。当组件的数据发生变化时，Vue 会首先创建一个虚拟 DOM\r\n      树，而不是直接修改真实的 DOM。\r\n    </p>\r\n    <p>\r\n      Diff 算法： 当数据发生变化时，Vue 会用新生成的虚拟 DOM 树与旧的虚拟 DOM\r\n      树进行比较（diff）。它通过最小化的更新策略，计算出最小的 DOM\r\n      变更，最终应用到真实的 DOM 上。\r\n      这一过程显著提升了渲染性能，尤其是在数据频繁变动的场景中。\r\n    </p>\r\n    <p>\r\n      总结：虚拟 DOM 和 Diff 算法的结合使得 Vue 在进行 DOM\r\n      更新时更加高效，减少了不必要的 DOM 操作，提高了性能。\r\n    </p>\r\n    <h3>十二、Vue 3 里面的劫持有哪些</h3>\r\n    <p>\r\n      Vue 3 使用 Proxy 来实现响应式系统，取代了 Vue 2 中的\r\n      Object.defineProperty。 Proxy\r\n      可以拦截对象的读取、设置、删除等操作，并通过代理机制来触发视图的更新。\r\n      通过对对象进行代理，Vue 3 可以更高效地追踪数据变化，并实现响应式更新。\r\n    </p>\r\n    <p>\r\n      总结：Vue 3 通过 Proxy 实现对数据的劫持和响应式更新，较 Vue 2\r\n      提升了性能并简化了代码逻辑。\r\n    </p>\r\n    <h3>十三、Vue SSR 的实现原理</h3>\r\n    <p>\r\n      Vue SSR（服务器端渲染）通过在服务器端渲染页面，再将渲染后的 HTML\r\n      发送给客户端，可以显著提升 SEO 和首屏加载性能。在 Vue 3 中，SSR 通过\r\n    </p>\r\n    <p>\r\n      renderToString 和 createApp 实现。 createApp：用于创建 Vue 应用的实例。\r\n    </p>\r\n    <p>renderToString：将 Vue 应用渲染为 HTML 字符串并返回给客户端。</p>\r\n    <p>\r\n      这种机制让客户端能够尽早展示页面内容，而不是等待 JavaScript\r\n      加载和执行后再渲染，从而提升了性能和 SEO。\r\n    </p>\r\n    <h3>十四、props和data的优先级谁高</h3>\r\n    <p>props > methosd > data > computed > watch</p>\r\n    <h3>十五、路由独享</h3>\r\n    <p>{</p>\r\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;path: '/mainpage',</p>\r\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;name: 'About',</p>\r\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;component: About, // 路由独享守卫</p>\r\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;beforeEnter:(to,from,next) => {</p>\r\n    <p>\r\n      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&nbsp;(from.name\r\n      === '/mainpage/about'){\r\n    </p>\r\n    <p>\r\n      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(\"这是从about来的\")\r\n    </p>\r\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;else{</p>\r\n    <p>\r\n      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(\"这不是从about来的\")\r\n    </p>\r\n    <p>\r\n      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} next(); //\r\n      必须调用来进行下一步操作。否则是不会跳转的\r\n    </p>\r\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>\r\n    <p>}</p>\r\n    <h3>十六、常见的事件修饰符及其作用</h3>\r\n    <p>\r\n      .stop： 防止事件冒泡（等同于 JavaScript 中的 event.stopPropagation()）\r\n    </p>\r\n    <p>\r\n      .prevent：\r\n      防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）等同于\r\n      JavaScript 中的 event.preventDefault()\r\n    </p>\r\n    <p>.capture ：与事件冒泡的方向相反，事件捕获由外到内；</p>\r\n    <p>.self ：只会触发自己范围内的事件，不包含子元素；</p>\r\n    <p>.once ：只会触发一次。</p>\r\n    <img src=\"@/assets/images/2.gif\" />\r\n    <!-- <h3>十七、</h3> -->\r\n\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n    <p></p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {};\r\n  },\r\n};\r\n</script>\r\n<style scoped></style>\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./vue.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./vue.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./vue.vue?vue&type=template&id=29a2feba&scoped=true&\"\nimport script from \"./vue.vue?vue&type=script&lang=js&\"\nexport * from \"./vue.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"29a2feba\",\n  null\n  \n)\n\nexport default component.exports","module.exports = __webpack_public_path__ + \"img/2.37c2c03d.gif\";"],"sourceRoot":""}