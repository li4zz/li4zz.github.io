{"version":3,"sources":["webpack:///./src/views/call-bind-apply.vue","webpack:///src/views/call-bind-apply.vue","webpack:///./src/views/call-bind-apply.vue?5241","webpack:///./src/views/call-bind-apply.vue?0b18"],"names":["render","_vm","this","_self","_c","_m","staticRenderFns","_v","staticStyle","data","component"],"mappings":"0HAAA,IAAIA,EAAS,WAAkB,IAAIC,EAAIC,KAAQD,EAAIE,MAAMC,GAAG,OAAOH,EAAII,GAAG,IAEtEC,EAAkB,CAAC,WAAY,IAAIL,EAAIC,KAAKE,EAAGH,EAAIE,MAAMC,GAAG,OAAOA,EAAG,MAAM,CAACH,EAAIM,GAAG,6FAA6FH,EAAG,IAAI,CAACH,EAAIM,GAAG,wBAA0BH,EAAG,IAAI,CAACH,EAAIM,GAAG,iFAAmFH,EAAG,IAAI,CAACH,EAAIM,GAAG,yCAAyCH,EAAG,IAAI,CAACH,EAAIM,GAAG,sDAAsDH,EAAG,IAAI,CAACH,EAAIM,GAAG,qLAAqLH,EAAG,IAAI,CAACH,EAAIM,GAAG,2DAA2DH,EAAG,MAAM,CAACI,YAAY,CAAC,aAAa,UAAUJ,EAAG,IAAI,CAACI,YAAY,CAAC,cAAc,SAAS,CAACP,EAAIM,GAAG,WAAWH,EAAG,IAAI,CAACH,EAAIM,GAAG,qGAAqGH,EAAG,IAAI,CAACH,EAAIM,GAAG,qDAAqDH,EAAG,IAAI,CAACH,EAAIM,GAAG,+BAAiCH,EAAG,IAAI,CAACH,EAAIM,GAAG,2DAA2DH,EAAG,IAAI,CAACH,EAAIM,GAAG,6BAA6BH,EAAG,IAAI,CAACH,EAAIM,GAAG,sDAAsDH,EAAG,IAAI,CAACH,EAAIM,GAAG,2CAA2CH,EAAG,IAAI,CAACH,EAAIM,GAAG,gDAAgDH,EAAG,IAAI,CAACI,YAAY,CAAC,cAAc,SAAS,CAACP,EAAIM,GAAG,UAAUH,EAAG,IAAI,CAACH,EAAIM,GAAG,iGAAiGH,EAAG,IAAI,CAACH,EAAIM,GAAG,qDAAqDH,EAAG,IAAI,CAACH,EAAIM,GAAG,+BAAiCH,EAAG,IAAI,CAACH,EAAIM,GAAG,sDAAsDH,EAAG,IAAI,CAACH,EAAIM,GAAG,6BAA6BH,EAAG,IAAI,CAACH,EAAIM,GAAG,4DAA4DH,EAAG,IAAI,CAACH,EAAIM,GAAG,0CAA0CH,EAAG,IAAI,CAACH,EAAIM,GAAG,+CAA+CH,EAAG,IAAI,CAACI,YAAY,CAAC,cAAc,SAAS,CAACP,EAAIM,GAAG,UAAUH,EAAG,IAAI,CAACH,EAAIM,GAAG,yFAAyFH,EAAG,IAAI,CAACH,EAAIM,GAAG,+BAAiCH,EAAG,IAAI,CAACH,EAAIM,GAAG,0EAA0EH,EAAG,IAAI,CAACH,EAAIM,GAAG,gFAAgFH,EAAG,IAAI,CAACH,EAAIM,GAAG,6BAA6BH,EAAG,IAAI,CAACI,YAAY,CAAC,cAAc,SAAS,CAACP,EAAIM,GAAG,QAAQH,EAAG,IAAI,CAACH,EAAIM,GAAG,2CAA2CH,EAAG,IAAI,CAACH,EAAIM,GAAG,0BAA0BH,EAAG,IAAI,CAACH,EAAIM,GAAG,8EAA8EH,EAAG,IAAI,CAACH,EAAIM,GAAG,kFAAkFH,EAAG,IAAI,CAACH,EAAIM,GAAG,8CAA8CH,EAAG,SCiFjvF,GACfK,OACA,WCrFyV,I,YCOrVC,EAAY,eACd,EACAV,EACAM,GACA,EACA,KACA,WACA,MAIa,aAAAI,E","file":"js/call-bind-apply.e80db889.js","sourcesContent":["var render = function render(){var _vm=this,_c=_vm._self._c;return _vm._m(0)\n}\nvar staticRenderFns = [function (){var _vm=this,_c=_vm._self._c;return _c('div',[_vm._v(\" call 、 apply 、 bind 作⽤是改变函数执⾏时的上下⽂，简⽽⾔之就是改变函数运⾏时 的 this 指向 那么什么情况下需要改变 this 的指向呢？下⾯举个例⼦ \"),_c('p',[_vm._v(\"var name = \\\"lucy\\\";\")]),_c('p',[_vm._v(\" var obj = { name: \\\"martin\\\", say: function () { console.log(this.name)} }; \")]),_c('p',[_vm._v(\"obj.say(); // martin，this 指向 obj 对象\")]),_c('p',[_vm._v(\"setTimeout(obj.say,0); // lucy，this 指向 window 对象\")]),_c('p',[_vm._v(\" 从上⾯可以看到，正常情况 say ⽅法输出 martin 但是我们把 say 放在 setTimeout ⽅法中，在定时器中是作为回调函数来执⾏的，因此回到主栈执 ⾏时是在全局执⾏上下⽂的环境中执⾏的，这时候 this 指向 window ，所以输出 lucy 我们实际需要的是 this 指向 obj 对象，这时候就需要该改变 this 指向了 \")]),_c('p',[_vm._v(\"setTimeout(obj.say.bind(obj),0); //martin，this指向obj对象\")]),_c('div',{staticStyle:{\"margin-top\":\"30px\"}}),_c('p',{staticStyle:{\"font-weight\":\"bold\"}},[_vm._v(\"apply\")]),_c('p',[_vm._v(\" apply 接受两个参数，第⼀个参数是 this 的指向，第⼆个参数是函数接受的参数，以数组的形式传 ⼊ 改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次 \")]),_c('p',[_vm._v(\"function fn(...args){ console.log(this,args); }\")]),_c('p',[_vm._v(\"let obj = { myname:\\\"张三\\\" }\")]),_c('p',[_vm._v(\" fn.apply(obj,[1,2]); // this会变成传⼊的obj，传⼊的参数必须是⼀个数组； \")]),_c('p',[_vm._v(\"fn(1,2) // this指向window\")]),_c('p',[_vm._v(\"当第⼀个参数为 null 、 undefined 的时候，默认指向 window (在浏览器中)\")]),_c('p',[_vm._v(\"fn.apply(null,[1,2]); // this指向window\")]),_c('p',[_vm._v(\"fn.apply(undefined,[1,2]); // this指向window\")]),_c('p',{staticStyle:{\"font-weight\":\"bold\"}},[_vm._v(\"call\")]),_c('p',[_vm._v(\" call ⽅法的第⼀个参数也是 this 的指向，后⾯传⼊的是⼀个参数列表 跟 apply ⼀样，改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次 \")]),_c('p',[_vm._v(\"function fn(...args){ console.log(this,args); }\")]),_c('p',[_vm._v(\"let obj = { myname:\\\"张三\\\" }\")]),_c('p',[_vm._v(\"fn.call(obj,1,2); // this会变成传⼊的obj，传⼊的参数必须是⼀个数组；\")]),_c('p',[_vm._v(\"fn(1,2) // this指向window\")]),_c('p',[_vm._v(\" 同样的，当第⼀个参数为 null 、 undefined 的时候，默认指向 window (在浏览器中) \")]),_c('p',[_vm._v(\"fn.call(null,[1,2]); // this指向window\")]),_c('p',[_vm._v(\"fn.call(undefined,[1,2]); // this指向window\")]),_c('p',{staticStyle:{\"font-weight\":\"bold\"}},[_vm._v(\"bind\")]),_c('p',[_vm._v(\" bind⽅法和call很相似，第⼀参数也是 this 的指向，后⾯传⼊的也是⼀个参数列表(但是这个参数列表 可以分多次传⼊) 改变 this 指向后不会⽴即执⾏， \")]),_c('p',[_vm._v(\"let obj = { myname:\\\"张三\\\" }\")]),_c('p',[_vm._v(\" const bindFn = fn.bind(obj); // this 也会变成传⼊的obj ，bind不是⽴即执⾏需要执 ⾏⼀次 \")]),_c('p',[_vm._v(\" function fn(...args){ console.log(this,args); } bindFn(1,2) // this指向obj \")]),_c('p',[_vm._v(\"fn(1,2) // this指向window\")]),_c('p',{staticStyle:{\"font-weight\":\"bold\"}},[_vm._v(\"⼩结\")]),_c('p',[_vm._v(\"从上⾯可以看到， apply 、 call 、 bind 三者的区别在于：\")]),_c('p',[_vm._v(\"三者都可以改变函数的 this 对象指向\")]),_c('p',[_vm._v(\" 三者第⼀个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 nul l ，则默认指向全局 window \")]),_c('p',[_vm._v(\" 三者都可以传参，但是 apply 是数组，⽽ call 是参数列表，且 apply 和 call 是⼀次性传 ⼊参数，⽽ bind 可以分为多次传⼊ \")]),_c('p',[_vm._v(\"bind 是返回绑定this之后的函数， apply 、 call 则是⽴即执⾏\")]),_c('p')])\n}]\n\nexport { render, staticRenderFns }","<!-- call/bind/apply -->\r\n<template>\r\n  <div>\r\n    call 、 apply 、 bind\r\n    作⽤是改变函数执⾏时的上下⽂，简⽽⾔之就是改变函数运⾏时 的 this 指向\r\n    那么什么情况下需要改变 this 的指向呢？下⾯举个例⼦\r\n    <p>var name = \"lucy\";</p>\r\n    <p>\r\n      var obj = { name: \"martin\", say: function () { console.log(this.name)} };\r\n    </p>\r\n    <p>obj.say(); // martin，this 指向 obj 对象</p>\r\n    <p>setTimeout(obj.say,0); // lucy，this 指向 window 对象</p>\r\n    <p>\r\n      从上⾯可以看到，正常情况 say ⽅法输出 martin 但是我们把 say 放在\r\n      setTimeout ⽅法中，在定时器中是作为回调函数来执⾏的，因此回到主栈执\r\n      ⾏时是在全局执⾏上下⽂的环境中执⾏的，这时候 this 指向 window ，所以输出\r\n      lucy 我们实际需要的是 this 指向 obj 对象，这时候就需要该改变 this 指向了\r\n    </p>\r\n    <p>setTimeout(obj.say.bind(obj),0); //martin，this指向obj对象</p>\r\n    <div style=\"margin-top: 30px\"></div>\r\n    <p style=\"font-weight: bold\">apply</p>\r\n    <p>\r\n      apply 接受两个参数，第⼀个参数是 this\r\n      的指向，第⼆个参数是函数接受的参数，以数组的形式传 ⼊ 改变 this\r\n      指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次\r\n    </p>\r\n    <p>function fn(...args){ console.log(this,args); }</p>\r\n    <p>let obj = { myname:\"张三\" }</p>\r\n    <p>\r\n      fn.apply(obj,[1,2]); // this会变成传⼊的obj，传⼊的参数必须是⼀个数组；\r\n    </p>\r\n    <p>fn(1,2) // this指向window</p>\r\n    <p>当第⼀个参数为 null 、 undefined 的时候，默认指向 window (在浏览器中)</p>\r\n    <p>fn.apply(null,[1,2]); // this指向window</p>\r\n    <p>fn.apply(undefined,[1,2]); // this指向window</p>\r\n    <p style=\"font-weight: bold\">call</p>\r\n    <p>\r\n      call ⽅法的第⼀个参数也是 this 的指向，后⾯传⼊的是⼀个参数列表 跟 apply\r\n      ⼀样，改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次\r\n    </p>\r\n    <p>function fn(...args){ console.log(this,args); }</p>\r\n    <p>let obj = { myname:\"张三\" }</p>\r\n    <p>fn.call(obj,1,2); // this会变成传⼊的obj，传⼊的参数必须是⼀个数组；</p>\r\n    <p>fn(1,2) // this指向window</p>\r\n    <p>\r\n      同样的，当第⼀个参数为 null 、 undefined 的时候，默认指向 window\r\n      (在浏览器中)\r\n    </p>\r\n    <p>fn.call(null,[1,2]); // this指向window</p>\r\n    <p>fn.call(undefined,[1,2]); // this指向window</p>\r\n    <p style=\"font-weight: bold\">bind</p>\r\n    <p>\r\n      bind⽅法和call很相似，第⼀参数也是 this\r\n      的指向，后⾯传⼊的也是⼀个参数列表(但是这个参数列表 可以分多次传⼊) 改变\r\n      this 指向后不会⽴即执⾏，\r\n    </p>\r\n\r\n    <p>let obj = { myname:\"张三\" }</p>\r\n    <p>\r\n      const bindFn = fn.bind(obj); // this 也会变成传⼊的obj\r\n      ，bind不是⽴即执⾏需要执 ⾏⼀次\r\n    </p>\r\n    <p>\r\n      function fn(...args){ console.log(this,args); } bindFn(1,2) // this指向obj\r\n    </p>\r\n    <p>fn(1,2) // this指向window</p>\r\n    <p style=\"font-weight: bold\">⼩结</p>\r\n    <p>从上⾯可以看到， apply 、 call 、 bind 三者的区别在于：</p>\r\n    <p>三者都可以改变函数的 this 对象指向</p>\r\n    <p>\r\n      三者第⼀个参数都是 this 要指向的对象，如果如果没有这个参数或参数为\r\n      undefined 或 nul l ，则默认指向全局 window\r\n    </p>\r\n    <p>\r\n      三者都可以传参，但是 apply 是数组，⽽ call 是参数列表，且 apply 和 call\r\n      是⼀次性传 ⼊参数，⽽ bind 可以分为多次传⼊\r\n    </p>\r\n    <p>bind 是返回绑定this之后的函数， apply 、 call 则是⽴即执⾏</p>\r\n    <p></p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {};\r\n  },\r\n};\r\n</script>\r\n<style scoped></style>\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./call-bind-apply.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./call-bind-apply.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./call-bind-apply.vue?vue&type=template&id=8bebf24a&scoped=true&\"\nimport script from \"./call-bind-apply.vue?vue&type=script&lang=js&\"\nexport * from \"./call-bind-apply.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"8bebf24a\",\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}