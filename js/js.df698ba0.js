(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["js"],{"33b2":function(p,t,n){p.exports=n.p+"img/4.7bfb25e4.png"},"619a":function(p,t){p.exports="data:image/png;base64,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"},"6c10":function(p,t,n){"use strict";n.r(t);var o=function(){var p=this;p._self._c;return p._m(0)},i=[function(){var p=this,t=p._self._c;return t("div",[t("h3",[p._v("一、闭包")]),t("p",[p._v(" 当一个函数中的内部函数被拿到函数外部调用，又因为在js中内层作用域总是能访问外层作用域的变量，那么内部函数存在对外部函数中变量的引用，这些变量的集合称之为闭包。 ")]),t("p",[p._v("function foo() {")]),t("p",[p._v("let a = 1")]),t("p",[p._v("let b = 2")]),t("p",[p._v("function bar() {")]),t("p",[p._v("    console.log(a); // 这里的a就是闭包")]),t("p",[p._v("}")]),t("p",[p._v("return bar")]),t("p",[p._v("}")]),t("p",[p._v("let baz = foo()")]),t("p",[p._v("baz() // 1")]),t("p",[p._v(" 应用场景：1，创建私有变量 （全局变量不易维护）,2，延长变量的生命周期 ,3，实现柯里化（颗粒） ")]),t("p",[p._v("缺点：内存泄露：函数的执行上下文销毁的不彻底，内存空间变小")]),t("h3",[p._v("二、什么是柯里化（颗粒化）")]),t("p",[p._v("将一个接受多个参数的函数转变成多个只接受一个参数的函数")]),t("p",[p._v("function add(a, b, c) {")]),t("p",[p._v("    return a + b + c")]),t("p",[p._v("}")]),t("p",[p._v("function add(a) {")]),t("p",[p._v("    return function(b) {")]),t("p",[p._v("        return function(c) {")]),t("p",[p._v("             return a + b + c ")]),t("p",[p._v("        }")]),t("p",[p._v("   }")]),t("p",[p._v("}")]),t("p",[p._v("const res = add(1)(2)(3)")]),t("p",[p._v("console.log(res); // 6")]),t("h3",[p._v("三、作用域")]),t("p",[p._v("作用域是什么：变量和函数能够生效的区域，这个区域叫作用域")]),t("p",[p._v(" 全局作用域： 在V8执行代码的过程中会进行预编译，预编译会生成一个全局执行上下文， 这个全局执行上下文就是全局作用域，里面定义了声明在最外层的变量和函数 ")]),t("p",[p._v(" 函数体作用域： 在代码的执行过程中，遇到函数的调用时会生成一个函数的执行上下文，这个函数执行上下文就是函数体的作用域，里面定义了声明在函数内部的变量和函数 ")]),t("p",[p._v("块级作用域： let或const和{}形成的区域就叫做块级作用域")]),t("p",[p._v(" 作用域链：作用域只能从内到外的访问，这种访问规则形成的链状关系我们称之为作用域链 ")]),t("p",[p._v("词法作用域：指的是函数或变量定义的区域")]),t("img",{attrs:{src:n("619a")}}),t("h3",[p._v(" 四、call 、 apply 、 bind 作⽤是改变函数执⾏时的上下⽂，简⽽⾔之就是改变函数运⾏时 的 this 指向 那么什么情况下需要改变 this 的指向呢？ ")]),t("p",[p._v('var name = "lucy";')]),t("p",[p._v(' var obj = { name: "martin", say: function () { console.log(this.name)} }; ')]),t("p",[p._v("obj.say(); // martin，this 指向 obj 对象")]),t("p",[p._v("setTimeout(obj.say,0); // lucy，this 指向 window 对象")]),t("p",[p._v(" 从上⾯可以看到，正常情况 say ⽅法输出 martin 但是我们把 say 放在 setTimeout ⽅法中，在定时器中是作为回调函数来执⾏的，因此回到主栈执 ⾏时是在全局执⾏上下⽂的环境中执⾏的，这时候 this 指向 window ，所以输出 lucy 我们实际需要的是 this 指向 obj 对象，这时候就需要该改变 this 指向了 ")]),t("p",[p._v("setTimeout(obj.say.bind(obj),0); //martin，this指向obj对象")]),t("div",{staticStyle:{"margin-top":"30px"}}),t("p",{staticStyle:{"font-weight":"bold"}},[p._v("apply")]),t("p",[p._v(" apply 接受两个参数，第⼀个参数是 this 的指向，第⼆个参数是函数接受的参数，以数组的形式传 ⼊ 改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次 ")]),t("p",[p._v("function fn(...args){ console.log(this,args); }")]),t("p",[p._v('let obj = { myname:"张三" }')]),t("p",[p._v(" fn.apply(obj,[1,2]); // this会变成传⼊的obj，传⼊的参数必须是⼀个数组； ")]),t("p",[p._v("fn(1,2) // this指向window")]),t("p",[p._v("当第⼀个参数为 null 、 undefined 的时候，默认指向 window (在浏览器中)")]),t("p",[p._v("fn.apply(null,[1,2]); // this指向window")]),t("p",[p._v("fn.apply(undefined,[1,2]); // this指向window")]),t("p",{staticStyle:{"font-weight":"bold"}},[p._v("call")]),t("p",[p._v(" call ⽅法的第⼀个参数也是 this 的指向，后⾯传⼊的是⼀个参数列表 跟 apply ⼀样，改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次 ")]),t("p",[p._v("function fn(...args){ console.log(this,args); }")]),t("p",[p._v('let obj = { myname:"张三" }')]),t("p",[p._v("fn.call(obj,1,2); // this会变成传⼊的obj，传⼊的参数必须是⼀个数组；")]),t("p",[p._v("fn(1,2) // this指向window")]),t("p",[p._v(" 同样的，当第⼀个参数为 null 、 undefined 的时候，默认指向 window (在浏览器中) ")]),t("p",[p._v("fn.call(null,[1,2]); // this指向window")]),t("p",[p._v("fn.call(undefined,[1,2]); // this指向window")]),t("p",{staticStyle:{"font-weight":"bold"}},[p._v("bind")]),t("p",[p._v(" bind⽅法和call很相似，第⼀参数也是 this 的指向，后⾯传⼊的也是⼀个参数列表(但是这个参数列表 可以分多次传⼊) 改变 this 指向后不会⽴即执⾏， ")]),t("p",[p._v('let obj = { myname:"张三" }')]),t("p",[p._v(" const bindFn = fn.bind(obj); // this 也会变成传⼊的obj ，bind不是⽴即执⾏需要执 ⾏⼀次 ")]),t("p",[p._v(" function fn(...args){ console.log(this,args); } bindFn(1,2) // this指向obj ")]),t("p",[p._v("fn(1,2) // this指向window")]),t("p",{staticStyle:{"font-weight":"bold"}},[p._v("⼩结")]),t("p",[p._v("从上⾯可以看到， apply 、 call 、 bind 三者的区别在于：")]),t("p",[p._v("三者都可以改变函数的 this 对象指向")]),t("p",[p._v(" 三者第⼀个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 nul l ，则默认指向全局 window ")]),t("p",[p._v(" 三者都可以传参，但是 apply 是数组，⽽ call 是参数列表，且 apply 和 call 是⼀次性传 ⼊参数，⽽ bind 可以分为多次传⼊ ")]),t("p",[p._v("bind 是返回绑定this之后的函数， apply 、 call 则是⽴即执⾏")]),t("img",{attrs:{src:n("33b2")}}),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p")])}],v={data(){return{}}},s=v,a=n("2877"),l=Object(a["a"])(s,o,i,!1,null,"525bb030",null);t["default"]=l.exports}}]);
//# sourceMappingURL=js.df698ba0.js.map